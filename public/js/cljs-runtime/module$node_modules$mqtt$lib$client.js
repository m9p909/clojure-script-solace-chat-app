shadow$provide.module$node_modules$mqtt$lib$client=function(global,require,module,exports){function sendPacket(client,packet,cb){debug("sendPacket :: packet: %O",packet);debug("sendPacket :: emitting `packetsend`");client.emit("packetsend",packet);debug("sendPacket :: writing to stream");packet=mqttPacket.writeToStream(packet,client.stream,client.options);debug("sendPacket :: writeToStream result %s",packet);!packet&&cb?(debug("sendPacket :: handle events on `drain` once through callback."),client.stream.once("drain",
cb)):cb&&(debug("sendPacket :: invoking cb"),cb())}function flush(queue){queue&&(debug("flush: queue exists? %b",!!queue),Object.keys(queue).forEach(function(messageId){"function"===typeof queue[messageId].cb&&(queue[messageId].cb(Error("Connection closed")),delete queue[messageId])}))}function flushVolatile(queue){queue&&(debug("flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function"),Object.keys(queue).forEach(function(messageId){queue[messageId].volatile&&
"function"===typeof queue[messageId].cb&&(queue[messageId].cb(Error("Connection closed")),delete queue[messageId])}))}function storeAndSend(client,packet,cb,cbStorePut){debug("storeAndSend :: store packet with cmd %s to outgoingStore",packet.cmd);client.outgoingStore.put(packet,function(err){if(err)return cb&&cb(err);cbStorePut();sendPacket(client,packet,cb)})}function nop(error){debug("nop ::",error)}function MqttClient(streamBuilder,options){var k,that=this;if(!(this instanceof MqttClient))return new MqttClient(streamBuilder,
options);this.options=options||{};for(k in defaultConnectOptions)this.options[k]="undefined"===typeof this.options[k]?defaultConnectOptions[k]:options[k];debug("MqttClient :: options.protocol",options.protocol);debug("MqttClient :: options.protocolVersion",options.protocolVersion);debug("MqttClient :: options.username",options.username);debug("MqttClient :: options.keepalive",options.keepalive);debug("MqttClient :: options.reconnectPeriod",options.reconnectPeriod);debug("MqttClient :: options.rejectUnauthorized",
options.rejectUnauthorized);this.options.clientId="string"===typeof options.clientId?options.clientId:"mqttjs_"+Math.random().toString(16).substr(2,8);debug("MqttClient :: clientId",this.options.clientId);this.options.customHandleAcks=5===options.protocolVersion&&options.customHandleAcks?options.customHandleAcks:function(){arguments[3](0)};this.streamBuilder=streamBuilder;this.outgoingStore=options.outgoingStore||new Store;this.incomingStore=options.incomingStore||new Store;this.queueQoSZero=void 0===
options.queueQoSZero?!0:options.queueQoSZero;this._resubscribeTopics={};this.messageIdToTopic={};this.pingTimer=null;this.disconnecting=this.connected=!1;this.queue=[];this.reconnectTimer=this.connackTimer=null;this._storeProcessing=!1;this._packetIdsDuringStoreProcessing={};this.nextId=Math.max(1,Math.floor(65535*Math.random()));this.outgoing={};this._firstConnection=!0;this.on("connect",function(){function deliver(){var entry=queue.shift();debug("deliver :: entry %o",entry);var packet=null;entry&&
(packet=entry.packet,debug("deliver :: call _sendPacket for %o",packet),that._sendPacket(packet,function(err){entry.cb&&entry.cb(err);deliver()}))}var queue=this.queue;debug("connect :: sending queued packets");deliver()});this.on("close",function(){debug("close :: connected set to `false`");this.connected=!1;debug("close :: clearing connackTimer");clearTimeout(this.connackTimer);debug("close :: clearing ping timer");null!==that.pingTimer&&(that.pingTimer.clear(),that.pingTimer=null);debug("close :: calling _setupReconnect");
this._setupReconnect()});EventEmitter.call(this);debug("MqttClient :: setting up stream");this._setupStream()}exports=require("module$node_modules$process$browser");"use strict";var EventEmitter=require("module$node_modules$events$events").EventEmitter,Store=require("module$node_modules$mqtt$lib$store"),mqttPacket=require("module$node_modules$mqtt_packet$mqtt"),Writable=require("module$node_modules$mqtt$node_modules$readable_stream$readable_browser").Writable,inherits=require("module$node_modules$inherits$inherits_browser"),
reInterval=require("module$node_modules$reinterval$index"),validations=require("module$node_modules$mqtt$lib$validations"),xtend=require("module$node_modules$xtend$immutable"),debug=require("module$node_modules$debug$src$browser")("mqttjs:client"),nextTick=exports?exports.nextTick:function(callback){setTimeout(callback,0)},setImmediate=global.setImmediate||function(callback){nextTick(callback)},defaultConnectOptions={keepalive:60,reschedulePings:!0,protocolId:"MQTT",protocolVersion:4,reconnectPeriod:1E3,
connectTimeout:3E4,clean:!0,resubscribe:!0},socketErrors=["ECONNREFUSED","EADDRINUSE","ECONNRESET","ENOTFOUND"],errors={0:"",1:"Unacceptable protocol version",2:"Identifier rejected",3:"Server unavailable",4:"Bad username or password",5:"Not authorized",16:"No matching subscribers",17:"No subscription existed",128:"Unspecified error",129:"Malformed Packet",130:"Protocol Error",131:"Implementation specific error",132:"Unsupported Protocol Version",133:"Client Identifier not valid",134:"Bad User Name or Password",
135:"Not authorized",136:"Server unavailable",137:"Server busy",138:"Banned",139:"Server shutting down",140:"Bad authentication method",141:"Keep Alive timeout",142:"Session taken over",143:"Topic Filter invalid",144:"Topic Name invalid",145:"Packet identifier in use",146:"Packet Identifier not found",147:"Receive Maximum exceeded",148:"Topic Alias invalid",149:"Packet too large",150:"Message rate too high",151:"Quota exceeded",152:"Administrative action",153:"Payload format invalid",154:"Retain not supported",
155:"QoS not supported",156:"Use another server",157:"Server moved",158:"Shared Subscriptions not supported",159:"Connection rate exceeded",160:"Maximum connect time",161:"Subscription Identifiers not supported",162:"Wildcard Subscriptions not supported"};inherits(MqttClient,EventEmitter);MqttClient.prototype._setupStream=function(){function nextTickWork(){if(packets.length)nextTick(work);else{var done=completeParse;completeParse=null;done()}}function work(){debug("work :: getting next packet in queue");
var packet=packets.shift();packet?(debug("work :: packet pulled from queue"),that._handlePacket(packet,nextTickWork)):(debug("work :: no packets in queue"),packet=completeParse,completeParse=null,debug("work :: done flag is %s",!!packet),packet&&packet())}var that=this;var connectPacket=new Writable;var parser=mqttPacket.parser(this.options),completeParse=null,packets=[];debug("_setupStream :: calling method to clear reconnect");this._clearReconnect();debug("_setupStream :: using streamBuilder provided to client to create stream");
this.stream=this.streamBuilder(this);parser.on("packet",function(packet){debug("parser :: on packet push to packets array.");packets.push(packet)});connectPacket._write=function(buf,enc,done){completeParse=done;debug("writable stream :: parsing buffer");parser.parse(buf);work()};debug("_setupStream :: pipe stream to writable stream");this.stream.pipe(connectPacket);this.stream.on("error",function(error){debug("streamErrorHandler :: error",error.message);socketErrors.includes(error.code)?(debug("streamErrorHandler :: emitting error"),
that.emit("error",error)):nop(error)});this.stream.on("close",function(){debug("(%s)stream :: on close",that.options.clientId);flushVolatile(that.outgoing);debug("stream: emit close to MqttClient");that.emit("close")});debug("_setupStream: sending packet `connect`");connectPacket=Object.create(this.options);connectPacket.cmd="connect";sendPacket(this,connectPacket);parser.on("error",this.emit.bind(this,"error"));if(this.options.properties){if(!this.options.properties.authenticationMethod&&this.options.properties.authenticationData)return that.end(()=>
this.emit("error",Error("Packet has no Authentication Method"))),this;this.options.properties.authenticationMethod&&this.options.authPacket&&"object"===typeof this.options.authPacket&&(connectPacket=xtend({cmd:"auth",reasonCode:0},this.options.authPacket),sendPacket(this,connectPacket))}this.stream.setMaxListeners(1E3);clearTimeout(this.connackTimer);this.connackTimer=setTimeout(function(){debug("!!connectTimeout hit!! Calling _cleanUp with force `true`");that._cleanUp(!0)},this.options.connectTimeout)};
MqttClient.prototype._handlePacket=function(packet,done){var options=this.options;if(5===options.protocolVersion&&options.properties&&options.properties.maximumPacketSize&&options.properties.maximumPacketSize<packet.length)return this.emit("error",Error("exceeding packets size "+packet.cmd)),this.end({reasonCode:149,properties:{reasonString:"Maximum packet size was exceeded"}}),this;debug("_handlePacket :: emitting packetreceive");this.emit("packetreceive",packet);switch(packet.cmd){case "publish":this._handlePublish(packet,
done);break;case "puback":case "pubrec":case "pubcomp":case "suback":case "unsuback":this._handleAck(packet);done();break;case "pubrel":this._handlePubrel(packet,done);break;case "connack":this._handleConnack(packet);done();break;case "pingresp":this._handlePingresp(packet);done();break;case "disconnect":this._handleDisconnect(packet),done()}};MqttClient.prototype._checkDisconnecting=function(callback){this.disconnecting&&(callback?callback(Error("client disconnecting")):this.emit("error",Error("client disconnecting")));
return this.disconnecting};MqttClient.prototype.publish=function(topic,message,opts,callback){debug("publish :: message `%s` to topic `%s`",message,topic);var options=this.options;"function"===typeof opts&&(callback=opts,opts=null);opts=xtend({qos:0,retain:!1,dup:!1},opts);if(this._checkDisconnecting(callback))return this;topic={cmd:"publish",topic,payload:message,qos:opts.qos,retain:opts.retain,messageId:this._nextId(),dup:opts.dup};5===options.protocolVersion&&(topic.properties=opts.properties,
(!options.properties&&topic.properties&&topic.properties.topicAlias||opts.properties&&options.properties&&(opts.properties.topicAlias&&options.properties.topicAliasMaximum&&opts.properties.topicAlias>options.properties.topicAliasMaximum||!options.properties.topicAliasMaximum&&opts.properties.topicAlias))&&delete topic.properties.topicAlias);debug("publish :: qos",opts.qos);switch(opts.qos){case 1:case 2:this.outgoing[topic.messageId]={volatile:!1,cb:callback||nop};this._storeProcessing?(debug("_storeProcessing enabled"),
this._packetIdsDuringStoreProcessing[topic.messageId]=!1,this._storePacket(topic,void 0,opts.cbStorePut)):(debug("MqttClient:publish: packet cmd: %s",topic.cmd),this._sendPacket(topic,void 0,opts.cbStorePut));break;default:this._storeProcessing?(debug("_storeProcessing enabled"),this._storePacket(topic,callback,opts.cbStorePut)):(debug("MqttClient:publish: packet cmd: %s",topic.cmd),this._sendPacket(topic,callback,opts.cbStorePut))}return this};MqttClient.prototype.subscribe=function(){var packet$jscomp$0=
Array(arguments.length);for(var i$jscomp$0=0;i$jscomp$0<arguments.length;i$jscomp$0++)packet$jscomp$0[i$jscomp$0]=arguments[i$jscomp$0];var subs=[],obj=packet$jscomp$0.shift(),resubscribe=obj.resubscribe,callback=packet$jscomp$0.pop()||nop,opts=packet$jscomp$0.pop(),that=this,version=this.options.protocolVersion;delete obj.resubscribe;"string"===typeof obj&&(obj=[obj]);"function"!==typeof callback&&(opts=callback,callback=nop);packet$jscomp$0=validations.validateTopics(obj);if(null!==packet$jscomp$0)return setImmediate(callback,
Error("Invalid topic "+packet$jscomp$0)),this;if(this._checkDisconnecting(callback))return debug("subscribe: discconecting true"),this;packet$jscomp$0={qos:0};5===version&&(packet$jscomp$0.nl=!1,packet$jscomp$0.rap=!1,packet$jscomp$0.rh=0);opts=xtend(packet$jscomp$0,opts);Array.isArray(obj)?obj.forEach(function(topic){debug("subscribe: array topic %s",topic);if(!that._resubscribeTopics.hasOwnProperty(topic)||that._resubscribeTopics[topic].qos<opts.qos||resubscribe)topic={topic,qos:opts.qos},5===version&&
(topic.nl=opts.nl,topic.rap=opts.rap,topic.rh=opts.rh,topic.properties=opts.properties),debug("subscribe: pushing topic `%s` and qos `%s` to subs list",topic.topic,topic.qos),subs.push(topic)}):Object.keys(obj).forEach(function(k){debug("subscribe: object topic %s",k);if(!that._resubscribeTopics.hasOwnProperty(k)||that._resubscribeTopics[k].qos<obj[k].qos||resubscribe){var currentOpts={topic:k,qos:obj[k].qos};5===version&&(currentOpts.nl=obj[k].nl,currentOpts.rap=obj[k].rap,currentOpts.rh=obj[k].rh,
currentOpts.properties=opts.properties);debug("subscribe: pushing `%s` to subs list",currentOpts);subs.push(currentOpts)}});packet$jscomp$0={cmd:"subscribe",subscriptions:subs,qos:1,retain:!1,dup:!1,messageId:this._nextId()};opts.properties&&(packet$jscomp$0.properties=opts.properties);if(subs.length){if(this.options.resubscribe){debug("subscribe :: resubscribe true");var topics=[];subs.forEach(function(sub){if(0<that.options.reconnectPeriod){var topic={qos:sub.qos};5===version&&(topic.nl=sub.nl||
!1,topic.rap=sub.rap||!1,topic.rh=sub.rh||0,topic.properties=sub.properties);that._resubscribeTopics[sub.topic]=topic;topics.push(sub.topic)}});that.messageIdToTopic[packet$jscomp$0.messageId]=topics}this.outgoing[packet$jscomp$0.messageId]={volatile:!0,cb:function(err,packet){if(!err){packet=packet.granted;for(var i=0;i<packet.length;i+=1)subs[i].qos=packet[i]}callback(err,subs)}};debug("subscribe :: call _sendPacket");this._sendPacket(packet$jscomp$0);return this}callback(null,[])};MqttClient.prototype.unsubscribe=
function(){for(var packet={cmd:"unsubscribe",qos:1,messageId:this._nextId()},that=this,args=Array(arguments.length),i=0;i<arguments.length;i++)args[i]=arguments[i];i=args.shift();var callback=args.pop()||nop;args=args.pop();"string"===typeof i&&(i=[i]);"function"!==typeof callback&&(args=callback,callback=nop);if(this._checkDisconnecting(callback))return this;"string"===typeof i?packet.unsubscriptions=[i]:Array.isArray(i)&&(packet.unsubscriptions=i);this.options.resubscribe&&packet.unsubscriptions.forEach(function(topic){delete that._resubscribeTopics[topic]});
"object"===typeof args&&args.properties&&(packet.properties=args.properties);this.outgoing[packet.messageId]={volatile:!0,cb:callback};debug("unsubscribe: call _sendPacket");this._sendPacket(packet);return this};MqttClient.prototype.end=function(force,opts,cb){function closeStores(){debug("end :: closeStores: closing incoming and outgoing stores");that.disconnected=!0;that.incomingStore.close(function(e1){that.outgoingStore.close(function(e2){debug("end :: closeStores: emitting end");that.emit("end");
cb&&(e2=e1||e2,debug("end :: closeStores: invoking callback with args"),cb(e2))})});that._deferredReconnect&&that._deferredReconnect()}function finish(){debug("end :: (%s) :: finish :: calling _cleanUp with force %s",that.options.clientId,force);that._cleanUp(force,()=>{debug("end :: finish :: calling process.nextTick on closeStores");nextTick(closeStores.bind(that))},opts)}var that=this;debug("end :: (%s)",this.options.clientId);if(null==force||"boolean"!==typeof force)cb=opts||nop,opts=force,force=
!1,"object"!==typeof opts&&(cb=opts,opts=null,"function"!==typeof cb&&(cb=nop));"object"!==typeof opts&&(cb=opts,opts=null);debug("end :: cb? %s",!!cb);cb=cb||nop;if(this.disconnecting)return cb(),this;this._clearReconnect();this.disconnecting=!0;!force&&0<Object.keys(this.outgoing).length?(debug("end :: (%s) :: calling finish in 10ms once outgoing is empty",that.options.clientId),this.once("outgoingEmpty",setTimeout.bind(null,finish,10))):(debug("end :: (%s) :: immediately calling finish",that.options.clientId),
finish());return this};MqttClient.prototype.removeOutgoingMessage=function(messageId){var cb=this.outgoing[messageId]?this.outgoing[messageId].cb:null;delete this.outgoing[messageId];this.outgoingStore.del({messageId},function(){cb(Error("Message removed"))});return this};MqttClient.prototype.reconnect=function(opts){debug("client reconnect");var that=this,f=function(){opts?(that.options.incomingStore=opts.incomingStore,that.options.outgoingStore=opts.outgoingStore):(that.options.incomingStore=null,
that.options.outgoingStore=null);that.incomingStore=that.options.incomingStore||new Store;that.outgoingStore=that.options.outgoingStore||new Store;that.disconnecting=!1;that.disconnected=!1;that._deferredReconnect=null;that._reconnect()};this.disconnecting&&!this.disconnected?this._deferredReconnect=f:f();return this};MqttClient.prototype._reconnect=function(){debug("_reconnect: emitting reconnect to client");this.emit("reconnect");this.connected?(this.end(()=>{this._setupStream()}),debug("client already connected. disconnecting first.")):
(debug("_reconnect: calling _setupStream"),this._setupStream())};MqttClient.prototype._setupReconnect=function(){var that=this;!that.disconnecting&&!that.reconnectTimer&&0<that.options.reconnectPeriod?(this.reconnecting||(debug("_setupReconnect :: emit `offline` state"),this.emit("offline"),debug("_setupReconnect :: set `reconnecting` to `true`"),this.reconnecting=!0),debug("_setupReconnect :: setting reconnectTimer for %d ms",that.options.reconnectPeriod),that.reconnectTimer=setInterval(function(){debug("reconnectTimer :: reconnect triggered!");
that._reconnect()},that.options.reconnectPeriod)):debug("_setupReconnect :: doing nothing...")};MqttClient.prototype._clearReconnect=function(){debug("_clearReconnect : clearing reconnect timer");this.reconnectTimer&&(clearInterval(this.reconnectTimer),this.reconnectTimer=null)};MqttClient.prototype._cleanUp=function(forced,done,JSCompiler_OptimizeArgumentsArray_p0){done&&(debug("_cleanUp :: done callback provided for on stream close"),this.stream.on("close",done));debug("_cleanUp :: forced? %s",
forced);forced?(0===this.options.reconnectPeriod&&this.options.clean&&flush(this.outgoing),debug("_cleanUp :: (%s) :: destroying stream",this.options.clientId),this.stream.destroy()):(forced=xtend({cmd:"disconnect"},JSCompiler_OptimizeArgumentsArray_p0),debug("_cleanUp :: (%s) :: call _sendPacket with disconnect packet",this.options.clientId),this._sendPacket(forced,setImmediate.bind(null,this.stream.end.bind(this.stream))));this.disconnecting||(debug("_cleanUp :: client not disconnecting. Clearing and resetting reconnect."),
this._clearReconnect(),this._setupReconnect());null!==this.pingTimer&&(debug("_cleanUp :: clearing pingTimer"),this.pingTimer.clear(),this.pingTimer=null);done&&!this.connected&&(debug("_cleanUp :: (%s) :: removing stream `done` callback `close` listener",this.options.clientId),this.stream.removeListener("close",done),done())};MqttClient.prototype._sendPacket=function(packet,cb,cbStorePut){debug("_sendPacket :: (%s) ::  start",this.options.clientId);cbStorePut=cbStorePut||nop;if(this.connected){this._shiftPingInterval();
switch(packet.cmd){case "publish":break;case "pubrel":storeAndSend(this,packet,cb,cbStorePut);return;default:sendPacket(this,packet,cb);return}switch(packet.qos){case 2:case 1:storeAndSend(this,packet,cb,cbStorePut);break;default:sendPacket(this,packet,cb)}debug("_sendPacket :: (%s) ::  end",this.options.clientId)}else debug("_sendPacket :: client not connected. Storing packet offline."),this._storePacket(packet,cb,cbStorePut)};MqttClient.prototype._storePacket=function(packet,cb,cbStorePut){debug("_storePacket :: packet: %o",
packet);debug("_storePacket :: cb? %s",!!cb);cbStorePut=cbStorePut||nop;0===(packet.qos||0)&&this.queueQoSZero||"publish"!==packet.cmd?this.queue.push({packet,cb}):0<packet.qos?(cb=this.outgoing[packet.messageId]?this.outgoing[packet.messageId].cb:null,this.outgoingStore.put(packet,function(err){if(err)return cb&&cb(err);cbStorePut()})):cb&&cb(Error("No connection to broker"))};MqttClient.prototype._setupPingTimer=function(){debug("_setupPingTimer :: keepalive %d (seconds)",this.options.keepalive);
var that=this;!this.pingTimer&&this.options.keepalive&&(this.pingResp=!0,this.pingTimer=reInterval(function(){that._checkPing()},1E3*this.options.keepalive))};MqttClient.prototype._shiftPingInterval=function(){this.pingTimer&&this.options.keepalive&&this.options.reschedulePings&&this.pingTimer.reschedule(1E3*this.options.keepalive)};MqttClient.prototype._checkPing=function(){debug("_checkPing :: checking ping...");this.pingResp?(debug("_checkPing :: ping response received. Clearing flag and sending `pingreq`"),
this.pingResp=!1,this._sendPacket({cmd:"pingreq"})):(debug("_checkPing :: calling _cleanUp with force true"),this._cleanUp(!0))};MqttClient.prototype._handlePingresp=function(){this.pingResp=!0};MqttClient.prototype._handleConnack=function(packet){debug("_handleConnack");var options=this.options,rc=5===options.protocolVersion?packet.reasonCode:packet.returnCode;clearTimeout(this.connackTimer);packet.properties&&(packet.properties.topicAliasMaximum&&(options.properties||(options.properties={}),options.properties.topicAliasMaximum=
packet.properties.topicAliasMaximum),packet.properties.serverKeepAlive&&options.keepalive&&(options.keepalive=packet.properties.serverKeepAlive,this._shiftPingInterval()),packet.properties.maximumPacketSize&&(options.properties||(options.properties={}),options.properties.maximumPacketSize=packet.properties.maximumPacketSize));0===rc?(this.reconnecting=!1,this._onConnect(packet)):0<rc&&(packet=Error("Connection refused: "+errors[rc]),packet.code=rc,this.emit("error",packet))};MqttClient.prototype._handlePublish=
function(packet,done){debug("_handlePublish: packet %o",packet);done="undefined"!==typeof done?done:nop;var topic=packet.topic.toString(),message=packet.payload,qos=packet.qos,messageId=packet.messageId,that=this,options=this.options,validReasonCodes=[0,16,128,131,135,144,145,151,153];debug("_handlePublish: qos %d",qos);switch(qos){case 2:options.customHandleAcks(topic,message,packet,function(error,code){error instanceof Error||(code=error,error=null);if(error)return that.emit("error",error);if(-1===
validReasonCodes.indexOf(code))return that.emit("error",Error("Wrong reason code for pubrec"));code?that._sendPacket({cmd:"pubrec",messageId,reasonCode:code},done):that.incomingStore.put(packet,function(){that._sendPacket({cmd:"pubrec",messageId},done)})});break;case 1:options.customHandleAcks(topic,message,packet,function(error,code){error instanceof Error||(code=error,error=null);if(error)return that.emit("error",error);if(-1===validReasonCodes.indexOf(code))return that.emit("error",Error("Wrong reason code for puback"));
code||that.emit("message",topic,message,packet);that.handleMessage(packet,function(err){if(err)return done&&done(err);that._sendPacket({cmd:"puback",messageId,reasonCode:code},done)})});break;case 0:this.emit("message",topic,message,packet);this.handleMessage(packet,done);break;default:debug("_handlePublish: unknown QoS. Doing nothing.")}};MqttClient.prototype.handleMessage=function(packet,callback){callback()};MqttClient.prototype._handleAck=function(packet){var messageId=packet.messageId,type=packet.cmd,
response=null,cb=this.outgoing[messageId]?this.outgoing[messageId].cb:null,that=this;if(cb){debug("_handleAck :: packet type",type);switch(type){case "pubcomp":case "puback":(type=packet.reasonCode)&&0<type&&16!==type&&(response=Error("Publish error: "+errors[type]),response.code=type,cb(response,packet));delete this.outgoing[messageId];this.outgoingStore.del(packet,cb);break;case "pubrec":response={cmd:"pubrel",qos:2,messageId};(messageId=packet.reasonCode)&&0<messageId&&16!==messageId?(response=
Error("Publish error: "+errors[messageId]),response.code=messageId,cb(response,packet)):this._sendPacket(response);break;case "suback":delete this.outgoing[messageId];for(response=0;response<packet.granted.length;response++)0!==(packet.granted[response]&128)&&(type=this.messageIdToTopic[messageId])&&type.forEach(function(topic){delete that._resubscribeTopics[topic]});cb(null,packet);break;case "unsuback":delete this.outgoing[messageId];cb(null);break;default:that.emit("error",Error("unrecognized packet type"))}this.disconnecting&&
0===Object.keys(this.outgoing).length&&this.emit("outgoingEmpty")}else debug("_handleAck :: Server sent an ack in error. Ignoring.")};MqttClient.prototype._handlePubrel=function(packet,callback){debug("handling pubrel packet");callback="undefined"!==typeof callback?callback:nop;var that=this,comp={cmd:"pubcomp",messageId:packet.messageId};that.incomingStore.get(packet,function(err$jscomp$0,pub){err$jscomp$0?that._sendPacket(comp,callback):(that.emit("message",pub.topic,pub.payload,pub),that.handleMessage(pub,
function(err){if(err)return callback(err);that.incomingStore.del(pub,nop);that._sendPacket(comp,callback)}))})};MqttClient.prototype._handleDisconnect=function(packet){this.emit("disconnect",packet)};MqttClient.prototype._nextId=function(){var id=this.nextId++;65536===this.nextId&&(this.nextId=1);return id};MqttClient.prototype.getLastMessageId=function(){return 1===this.nextId?65535:this.nextId-1};MqttClient.prototype._resubscribe=function(connack){debug("_resubscribe");var _resubscribeTopicsKeys=
Object.keys(this._resubscribeTopics);if(!this._firstConnection&&(this.options.clean||5===this.options.protocolVersion&&!connack.sessionPresent)&&0<_resubscribeTopicsKeys.length)if(this.options.resubscribe)if(5===this.options.protocolVersion)for(debug("_resubscribe: protocolVersion 5"),connack=0;connack<_resubscribeTopicsKeys.length;connack++){var resubscribeTopic={};resubscribeTopic[_resubscribeTopicsKeys[connack]]=this._resubscribeTopics[_resubscribeTopicsKeys[connack]];resubscribeTopic.resubscribe=
!0;this.subscribe(resubscribeTopic,{properties:resubscribeTopic[_resubscribeTopicsKeys[connack]].properties})}else this._resubscribeTopics.resubscribe=!0,this.subscribe(this._resubscribeTopics);else this._resubscribeTopics={};this._firstConnection=!1};MqttClient.prototype._onConnect=function(packet$jscomp$0){function startStreamProcess(){function clearStoreProcessing(){that._storeProcessing=!1;that._packetIdsDuringStoreProcessing={}}function remove(){outStore.destroy();outStore=null;clearStoreProcessing()}
function storeDeliver(){if(outStore){that._storeProcessing=!0;var packet=outStore.read(1);if(packet)if(that._packetIdsDuringStoreProcessing[packet.messageId])storeDeliver();else if(that.disconnecting||that.reconnectTimer)outStore.destroy&&outStore.destroy();else{var cb=that.outgoing[packet.messageId]?that.outgoing[packet.messageId].cb:null;that.outgoing[packet.messageId]={volatile:!1,cb:function(err,status){cb&&cb(err,status);storeDeliver()}};that._packetIdsDuringStoreProcessing[packet.messageId]=
!0;that._sendPacket(packet)}else outStore.once("readable",storeDeliver)}}var outStore=that.outgoingStore.createStream();that.once("close",remove);outStore.on("error",function(err){clearStoreProcessing();that.removeListener("close",remove);that.emit("error",err)});outStore.on("end",function(){var allProcessed=!0,id;for(id in that._packetIdsDuringStoreProcessing)if(!that._packetIdsDuringStoreProcessing[id]){allProcessed=!1;break}allProcessed?(clearStoreProcessing(),that.removeListener("close",remove),
that.emit("connect",packet$jscomp$0)):startStreamProcess()});storeDeliver()}if(this.disconnected)this.emit("connect",packet$jscomp$0);else{var that=this;this._setupPingTimer();this._resubscribe(packet$jscomp$0);this.connected=!0;startStreamProcess()}};module.exports=MqttClient}
//# sourceMappingURL=module$node_modules$mqtt$lib$client.js.map
