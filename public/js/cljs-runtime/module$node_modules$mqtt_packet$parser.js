shadow$provide.module$node_modules$mqtt_packet$parser=function(global,require,module,exports){const bl=require("module$node_modules$bl$bl");global=require("module$node_modules$events$events");const Packet=require("module$node_modules$mqtt_packet$packet"),constants=require("module$node_modules$mqtt_packet$constants"),debug=require("module$node_modules$debug$src$browser")("mqtt-packet:parser");class Parser extends global{constructor(){super();this.parser=this.constructor.parser}static parser(opt){if(!(this instanceof
Parser))return(new Parser).parser(opt);this.settings=opt||{};this._states=["_parseHeader","_parseLength","_parsePayload","_newPacket"];this._resetState();return this}_resetState(){debug("_resetState: resetting packet, error, _list, and _stateCounter");this.packet=new Packet;this.error=null;this._list=bl();this._stateCounter=0}parse(buf){this.error&&this._resetState();this._list.append(buf);for(debug("parse: current state: %s",this._states[this._stateCounter]);(-1!==this.packet.length||0<this._list.length)&&
this[this._states[this._stateCounter]]()&&!this.error;)this._stateCounter++,debug("parse: state complete. _stateCounter is now: %d",this._stateCounter),debug("parse: packet.length: %d, buffer list length: %d",this.packet.length,this._list.length),this._stateCounter>=this._states.length&&(this._stateCounter=0);debug("parse: exited while loop. packet: %d, buffer list length: %d",this.packet.length,this._list.length);return this._list.length}_parseHeader(){const zero=this._list.readUInt8(0);this.packet.cmd=
constants.types[zero>>constants.CMD_SHIFT];this.packet.retain=0!==(zero&constants.RETAIN_MASK);this.packet.qos=zero>>constants.QOS_SHIFT&constants.QOS_MASK;this.packet.dup=0!==(zero&constants.DUP_MASK);debug("_parseHeader: packet: %o",this.packet);this._list.consume(1);return!0}_parseLength(){const result=this._parseVarByteNum(!0);result&&(this.packet.length=result.value,this._list.consume(result.bytes));debug("_parseLength %d",result.value);return!!result}_parsePayload(){debug("_parsePayload: payload %O",
this._list);let result=!1;if(0===this.packet.length||this._list.length>=this.packet.length){this._pos=0;switch(this.packet.cmd){case "connect":this._parseConnect();break;case "connack":this._parseConnack();break;case "publish":this._parsePublish();break;case "puback":case "pubrec":case "pubrel":case "pubcomp":this._parseConfirmation();break;case "subscribe":this._parseSubscribe();break;case "suback":this._parseSuback();break;case "unsubscribe":this._parseUnsubscribe();break;case "unsuback":this._parseUnsuback();
break;case "pingreq":case "pingresp":break;case "disconnect":this._parseDisconnect();break;case "auth":this._parseAuth();break;default:this._emitError(Error("Not supported"))}result=!0}debug("_parsePayload complete result: %s",result);return result}_parseConnect(){debug("_parseConnect");var topic;const packet=this.packet;var password=this._parseString();if(null===password)return this._emitError(Error("Cannot parse protocolId"));if("MQTT"!==password&&"MQIsdp"!==password)return this._emitError(Error("Invalid protocolId"));
packet.protocolId=password;if(this._pos>=this._list.length)return this._emitError(Error("Packet too short"));packet.protocolVersion=this._list.readUInt8(this._pos);128<=packet.protocolVersion&&(packet.bridgeMode=!0,packet.protocolVersion-=128);if(3!==packet.protocolVersion&&4!==packet.protocolVersion&&5!==packet.protocolVersion)return this._emitError(Error("Invalid protocol version"));this._pos++;if(this._pos>=this._list.length)return this._emitError(Error("Packet too short"));var username=this._list.readUInt8(this._pos)&
constants.USERNAME_MASK;password=this._list.readUInt8(this._pos)&constants.PASSWORD_MASK;if(topic=this._list.readUInt8(this._pos)&constants.WILL_FLAG_MASK)packet.will={},packet.will.retain=0!==(this._list.readUInt8(this._pos)&constants.WILL_RETAIN_MASK),packet.will.qos=(this._list.readUInt8(this._pos)&constants.WILL_QOS_MASK)>>constants.WILL_QOS_SHIFT;packet.clean=0!==(this._list.readUInt8(this._pos)&constants.CLEAN_SESSION_MASK);this._pos++;packet.keepalive=this._parseNum();if(-1===packet.keepalive)return this._emitError(Error("Packet too short"));
if(5===packet.protocolVersion){var properties=this._parseProperties();Object.getOwnPropertyNames(properties).length&&(packet.properties=properties)}properties=this._parseString();if(null===properties)return this._emitError(Error("Packet too short"));packet.clientId=properties;debug("_parseConnect: packet.clientId: %s",packet.clientId);if(topic){5===packet.protocolVersion&&(topic=this._parseProperties(),Object.getOwnPropertyNames(topic).length&&(packet.will.properties=topic));topic=this._parseString();
if(null===topic)return this._emitError(Error("Cannot parse will topic"));packet.will.topic=topic;debug("_parseConnect: packet.will.topic: %s",packet.will.topic);topic=this._parseBuffer();if(null===topic)return this._emitError(Error("Cannot parse will payload"));packet.will.payload=topic;debug("_parseConnect: packet.will.paylaod: %s",packet.will.payload)}if(username){username=this._parseString();if(null===username)return this._emitError(Error("Cannot parse username"));packet.username=username;debug("_parseConnect: packet.username: %s",
packet.username)}if(password){password=this._parseBuffer();if(null===password)return this._emitError(Error("Cannot parse password"));packet.password=password}this.settings=packet;debug("_parseConnect: complete");return packet}_parseConnack(){debug("_parseConnack");const packet=this.packet;if(1>this._list.length)return null;packet.sessionPresent=!!(this._list.readUInt8(this._pos++)&constants.SESSIONPRESENT_MASK);if(5===this.settings.protocolVersion)packet.reasonCode=2<=this._list.length?this._list.readUInt8(this._pos++):
0;else{if(2>this._list.length)return null;packet.returnCode=this._list.readUInt8(this._pos++)}if(-1===packet.returnCode||-1===packet.reasonCode)return this._emitError(Error("Cannot parse return code"));if(5===this.settings.protocolVersion){const properties=this._parseProperties();Object.getOwnPropertyNames(properties).length&&(packet.properties=properties)}debug("_parseConnack: complete")}_parsePublish(){debug("_parsePublish");const packet=this.packet;packet.topic=this._parseString();if(null===packet.topic)return this._emitError(Error("Cannot parse topic"));
if(!(0<packet.qos)||this._parseMessageId()){if(5===this.settings.protocolVersion){const properties=this._parseProperties();Object.getOwnPropertyNames(properties).length&&(packet.properties=properties)}packet.payload=this._list.slice(this._pos,packet.length);debug("_parsePublish: payload from buffer list: %o",packet.payload)}}_parseSubscribe(){debug("_parseSubscribe");const packet=this.packet;let qos;let nl;if(1!==packet.qos)return this._emitError(Error("Wrong subscribe header"));packet.subscriptions=
[];if(this._parseMessageId()){if(5===this.settings.protocolVersion){var rap=this._parseProperties();Object.getOwnPropertyNames(rap).length&&(packet.properties=rap)}for(;this._pos<packet.length;){var topic=this._parseString();if(null===topic)return this._emitError(Error("Cannot parse topic"));if(this._pos>=packet.length)return this._emitError(Error("Malformed Subscribe Payload"));var options=this._parseByte();qos=options&constants.SUBSCRIBE_OPTIONS_QOS_MASK;nl=0!==(options>>constants.SUBSCRIBE_OPTIONS_NL_SHIFT&
constants.SUBSCRIBE_OPTIONS_NL_MASK);rap=0!==(options>>constants.SUBSCRIBE_OPTIONS_RAP_SHIFT&constants.SUBSCRIBE_OPTIONS_RAP_MASK);options=options>>constants.SUBSCRIBE_OPTIONS_RH_SHIFT&constants.SUBSCRIBE_OPTIONS_RH_MASK;topic={topic,qos};5===this.settings.protocolVersion?(topic.nl=nl,topic.rap=rap,topic.rh=options):this.settings.bridgeMode&&(topic.rh=0,topic.rap=!0,topic.nl=!0);debug("_parseSubscribe: push subscription `%s` to subscription",topic);packet.subscriptions.push(topic)}}}_parseSuback(){debug("_parseSuback");
const packet=this.packet;this.packet.granted=[];if(this._parseMessageId()){if(5===this.settings.protocolVersion){const properties=this._parseProperties();Object.getOwnPropertyNames(properties).length&&(packet.properties=properties)}for(;this._pos<this.packet.length;)this.packet.granted.push(this._list.readUInt8(this._pos++))}}_parseUnsubscribe(){debug("_parseUnsubscribe");const packet=this.packet;packet.unsubscriptions=[];if(this._parseMessageId()){if(5===this.settings.protocolVersion){var properties=
this._parseProperties();Object.getOwnPropertyNames(properties).length&&(packet.properties=properties)}for(;this._pos<packet.length;){properties=this._parseString();if(null===properties)return this._emitError(Error("Cannot parse topic"));debug("_parseUnsubscribe: push topic `%s` to unsubscriptions",properties);packet.unsubscriptions.push(properties)}}}_parseUnsuback(){debug("_parseUnsuback");const packet=this.packet;if(!this._parseMessageId())return this._emitError(Error("Cannot parse messageId"));
if(5===this.settings.protocolVersion){const properties=this._parseProperties();Object.getOwnPropertyNames(properties).length&&(packet.properties=properties);for(packet.granted=[];this._pos<this.packet.length;)this.packet.granted.push(this._list.readUInt8(this._pos++))}}_parseConfirmation(){debug("_parseConfirmation: packet.cmd: `%s`",this.packet.cmd);const packet=this.packet;this._parseMessageId();if(5===this.settings.protocolVersion&&(2<packet.length?(packet.reasonCode=this._parseByte(),debug("_parseConfirmation: packet.reasonCode `%d`",
packet.reasonCode)):packet.reasonCode=0,3<packet.length)){const properties=this._parseProperties();Object.getOwnPropertyNames(properties).length&&(packet.properties=properties)}return!0}_parseDisconnect(){const packet=this.packet;debug("_parseDisconnect");if(5===this.settings.protocolVersion){packet.reasonCode=0<this._list.length?this._parseByte():0;const properties=this._parseProperties();Object.getOwnPropertyNames(properties).length&&(packet.properties=properties)}debug("_parseDisconnect result: true");
return!0}_parseAuth(){debug("_parseAuth");const packet=this.packet;if(5!==this.settings.protocolVersion)return this._emitError(Error("Not supported auth packet for this version MQTT"));packet.reasonCode=this._parseByte();const properties=this._parseProperties();Object.getOwnPropertyNames(properties).length&&(packet.properties=properties);debug("_parseAuth: result: true");return!0}_parseMessageId(){const packet=this.packet;packet.messageId=this._parseNum();if(null===packet.messageId)return this._emitError(Error("Cannot parse messageId")),
!1;debug("_parseMessageId: packet.messageId %d",packet.messageId);return!0}_parseString(maybeBuffer){maybeBuffer=this._parseNum();var end=maybeBuffer+this._pos;if(-1===maybeBuffer||end>this._list.length||end>this.packet.length)return null;end=this._list.toString("utf8",this._pos,end);this._pos+=maybeBuffer;debug("_parseString: result: %s",end);return end}_parseStringPair(){debug("_parseStringPair");return{name:this._parseString(),value:this._parseString()}}_parseBuffer(){const length=this._parseNum();
var end=length+this._pos;if(-1===length||end>this._list.length||end>this.packet.length)return null;end=this._list.slice(this._pos,end);this._pos+=length;debug("_parseBuffer: result: %o",end);return end}_parseNum(){if(2>this._list.length-this._pos)return-1;const result=this._list.readUInt16BE(this._pos);this._pos+=2;debug("_parseNum: result: %s",result);return result}_parse4ByteNum(){if(4>this._list.length-this._pos)return-1;const result=this._list.readUInt32BE(this._pos);this._pos+=4;debug("_parse4ByteNum: result: %s",
result);return result}_parseVarByteNum(fullInfoFlag){debug("_parseVarByteNum");let bytes=0,mul=1,value=0,result=!1,current;const padding=this._pos?this._pos:0;for(;4>bytes&&padding+bytes<this._list.length;){current=this._list.readUInt8(padding+bytes++);value+=mul*(current&constants.VARBYTEINT_MASK);mul*=128;if(0===(current&constants.VARBYTEINT_FIN_MASK)){result=!0;break}if(this._list.length<=bytes)break}!result&&4===bytes&&this._list.length>=bytes&&this._emitError(Error("Invalid variable byte integer"));
padding&&(this._pos+=bytes);result=result?fullInfoFlag?{bytes,value}:value:!1;debug("_parseVarByteNum: result: %o",result);return result}_parseByte(){let result;this._pos<this._list.length&&(result=this._list.readUInt8(this._pos),this._pos++);debug("_parseByte: result: %o",result);return result}_parseByType(type){debug("_parseByType: type: %s",type);switch(type){case "byte":return 0!==this._parseByte();case "int8":return this._parseByte();case "int16":return this._parseNum();case "int32":return this._parse4ByteNum();
case "var":return this._parseVarByteNum();case "string":return this._parseString();case "pair":return this._parseStringPair();case "binary":return this._parseBuffer()}}_parseProperties(){debug("_parseProperties");var length=this._parseVarByteNum();length=this._pos+length;const result={};for(;this._pos<length;){var type=this._parseByte();if(!type)return this._emitError(Error("Cannot parse property code type")),!1;type=constants.propertiesCodes[type];if(!type)return this._emitError(Error("Unknown property")),
!1;if("userProperties"===type){result[type]||(result[type]=Object.create(null));const currentUserProperty=this._parseByType(constants.propertiesTypes[type]);result[type][currentUserProperty.name]?(Array.isArray(result[type][currentUserProperty.name])||(result[type][currentUserProperty.name]=[result[type][currentUserProperty.name]]),result[type][currentUserProperty.name].push(currentUserProperty.value)):result[type][currentUserProperty.name]=currentUserProperty.value}else result[type]?(Array.isArray(result[type])||
(result[type]=[result[type]]),result[type].push(this._parseByType(constants.propertiesTypes[type]))):result[type]=this._parseByType(constants.propertiesTypes[type])}return result}_newPacket(){debug("_newPacket");this.packet&&(this._list.consume(this.packet.length),debug("_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d",this.packet.cmd,this.packet.payload,this.packet.length),this.emit("packet",this.packet));debug("_newPacket: new packet");this.packet=new Packet;
this._pos=0;return!0}_emitError(err){debug("_emitError");this.error=err;this.emit("error",err)}}module.exports=Parser}
//# sourceMappingURL=module$node_modules$mqtt_packet$parser.js.map
