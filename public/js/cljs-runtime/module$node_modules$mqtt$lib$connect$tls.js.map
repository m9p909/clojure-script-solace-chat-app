{
"version":3,
"file":"module$node_modules$mqtt$lib$connect$tls.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAA,wCAAA,CAA6D,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAErG,IAAIC,IAAMH,OAAA,CAAQ,cAAR,CAAV,CACII,MAAQJ,OAAA,CAAQ,uCAAR,CAAA,CAAiB,YAAjB,CA0CZC,OAAOC,CAAAA,OAAP,CAxCAG,QAAsB,CAACC,UAAD,CAAaC,IAAb,CAAmB,CAsBvCC,QAASA,gBAAgB,CAACC,GAAD,CAAM,CAEzBF,IAAKG,CAAAA,kBAAT,EACEJ,UAAWK,CAAAA,IAAX,CAAgB,OAAhB,CAAyBF,GAAzB,CAQFG,WAAWC,CAAAA,GAAX,EAX6B,CApB/BN,IAAKO,CAAAA,IAAL,CAAYP,IAAKO,CAAAA,IAAjB,EAAyB,IACzBP,KAAKQ,CAAAA,IAAL,CAAYR,IAAKS,CAAAA,QAAjB,EAA6BT,IAAKQ,CAAAA,IAAlC,EAA0C,WAC1CR,KAAKU,CAAAA,UAAL,CAAkBV,IAAKQ,CAAAA,IAEvBR,KAAKG,CAAAA,kBAAL,CAAsD,CAAA,CAAtD,GAA0BH,IAAKG,CAAAA,kBAE/B,QAAOH,IAAKW,CAAAA,IAEZd;KAAA,CAAM,uCAAN,CAA+CG,IAAKO,CAAAA,IAApD,CAA0DP,IAAKQ,CAAAA,IAA/D,CAAqER,IAAKG,CAAAA,kBAA1E,CAEA,KAAAE,WAAaT,GAAIgB,CAAAA,OAAJ,CAAYZ,IAAZ,CAEbK,WAAWQ,CAAAA,EAAX,CAAc,eAAd,CAA+B,QAAS,EAAG,CACrCb,IAAKG,CAAAA,kBAAT,EAA+B,CAACE,UAAWS,CAAAA,UAA3C,CACET,UAAWD,CAAAA,IAAX,CAAgB,OAAhB,CAA6BW,KAAJ,CAAU,oBAAV,CAAzB,CADF,CAGEV,UAAWW,CAAAA,cAAX,CAA0B,OAA1B,CAAmCf,eAAnC,CAJuC,CAA3C,CAsBAI,WAAWQ,CAAAA,EAAX,CAAc,OAAd,CAAuBZ,eAAvB,CACA,OAAOI,WArCgC,CAL4D;",
"sources":["node_modules/mqtt/lib/connect/tls.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mqtt$lib$connect$tls\"] = function(global,require,module,exports) {\n'use strict'\r\nvar tls = require('tls')\r\nvar debug = require('debug')('mqttjs:tls')\r\n\r\nfunction buildBuilder (mqttClient, opts) {\r\n  var connection\r\n  opts.port = opts.port || 8883\r\n  opts.host = opts.hostname || opts.host || 'localhost'\r\n  opts.servername = opts.host\r\n\r\n  opts.rejectUnauthorized = opts.rejectUnauthorized !== false\r\n\r\n  delete opts.path\r\n\r\n  debug('port %d host %s rejectUnauthorized %b', opts.port, opts.host, opts.rejectUnauthorized)\r\n\r\n  connection = tls.connect(opts)\r\n  /* eslint no-use-before-define: [2, \"nofunc\"] */\r\n  connection.on('secureConnect', function () {\r\n    if (opts.rejectUnauthorized && !connection.authorized) {\r\n      connection.emit('error', new Error('TLS not authorized'))\r\n    } else {\r\n      connection.removeListener('error', handleTLSerrors)\r\n    }\r\n  })\r\n\r\n  function handleTLSerrors (err) {\r\n    // How can I get verify this error is a tls error?\r\n    if (opts.rejectUnauthorized) {\r\n      mqttClient.emit('error', err)\r\n    }\r\n\r\n    // close this connection to match the behaviour of net\r\n    // otherwise all we get is an error from the connection\r\n    // and close event doesn't fire. This is a work around\r\n    // to enable the reconnect code to work the same as with\r\n    // net.createConnection\r\n    connection.end()\r\n  }\r\n\r\n  connection.on('error', handleTLSerrors)\r\n  return connection\r\n}\r\n\r\nmodule.exports = buildBuilder\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","tls","debug","buildBuilder","mqttClient","opts","handleTLSerrors","err","rejectUnauthorized","emit","connection","end","port","host","hostname","servername","path","connect","on","authorized","Error","removeListener"]
}
